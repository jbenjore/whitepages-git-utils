#!/usr/bin/perl -w

=head1 NAME

git-pushme - Push your current branch

=head1 DESCRIPTION

This will push the branch you're currently in to the remote that it's
tracking, if there is one.  This avoids having to correctly type the
current branch name, but gives you the benefit of not accidentally
pushing branches that aren't ready.

=head1 SYNOPSIS

    git-pushme [-f | --force] [<commit>]

        -f        - Force
        <commit>  - The name of a commit

=cut

Getopt::Long::Configure( 'bundling_override' );

Main( @ARGV );
exit;

use 5.005;
use strict;
use Getopt::Long ();
use Pod::Usage ();
use Carp ();

sub Main {

    # Command line options
    local @ARGV = @_;
    my $do_force = 0;
    Getopt::Long::GetOptions(
        force => \ $do_force,
        help  => \ &Pod::Usage::pod2usage,
    )
      or Pod::Usage::pod2usage();

    # Command line commit
    my $commit;
    if ( 1 == @ARGV ) {
        $commit = shift @ARGV;
    }

    # Command line argument handling is done
    if ( @ARGV ) {
        Pod::Usage::pod2usage();
    }

    # Get the current branch
    my $branch = Run( 'git symbolic-ref HEAD' );
    chomp $branch;
    $branch =~ s{^refs/heads/}{};
    if ( ! $branch ) {
        die "Not on any branch that I can find!\n";
    }

    # Get the remote
    my $remote = config( "branch.$branch.remote" );
    if ( ! $remote ) {
        die qq{Your branch is not tracking a remote branch.  Consider using "git corb"\n};
    }

    my $thing_to_push;
    if ( $commit ) {

        # Allow the user to specify a SHA that's not at the tip.  If
        # they make a mistake here, they should get a non fast-forward
        # error.
        $thing_to_push = "${commit}:$branch";
    }
    else {

        # The ordinary case. Just the branch.
        $thing_to_push = $branch;
    }

    # Push it!
    my @flags;
    if ( $do_force ) {
        push @flags, '-f';
    }
    exec 'git', 'push', @flags, $remote, $thing_to_push;
}

sub config {
    my ( $name ) = @_;
    my $value = `git config $name`;
    my $exit_value = $? >> 8;
    if ( 0 == $exit_value ) {
        chomp $value;
        return $value;
    }
    elsif ( 1 == $exit_value ) {
        # git config exits with 1 when the value doesn't exit
        return '';
    }
    else {
        Carp::croak(qq{"git config $name" unexpectedly returned exit value $exit_value});
    }
}

sub Run {
    my $result = `@_`;
    if ( $? ) {
        my $exit_code = $? >> 8;
        Carp::croak(qq{"@_" unexpectedly returned exit value $exit_code});
    }
    return $result;
}
